# cJSON 学习笔记

[项目源码](https://github.com/DaveGamble/cJSON#**example**)
[从零开始的 JSON 库教程](https://zhuanlan.zhihu.com/json-tutorial)
[cJSON库 API解析](https://blog.csdn.net/qq_42992084/article/details/113445340)

## 一、 环境配置

```sh
git clone git@github.com:DaveGamble/cJSON.git
mkdir bulid
cd build
cmake ..
```

详细内容请参见[项目源码](https://github.com/DaveGamble/cJSON#**example**)内`README`。

## 二、JSON

> **JSON是什么**

JSON（JavaScript Object Notation）是一个用于数据交换的文本格式，现时的标准为[ECMA-404](https://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf)。

虽然 JSON 源至于 JavaScript 语言，但它只是一种数据格式，可用于任何编程语言。现时具类似功能的格式有 XML、YAML，当中以 JSON 的语法最为简单。

例如，一个动态网页想从服务器获得数据时，服务器从数据库查找数据，然后把数据转换成 JSON 文本格式：

```js
{
    "title": "Design Patterns",
    "subtitle": "Elements of Reusable Object-Oriented Software",
    "author": [
        "Erich Gamma",
        "Richard Helm",
        "Ralph Johnson",
        "John Vlissides"
    ],
    "year": 2009,
    "weight": 1.8,
    "hardcover": true,
    "publisher": {
        "Company": "Pearson Education",
        "Country": "India"
    },
    "website": null
}
```

网页的脚本代码就可以把此 JSON 文本解析为内部的数据结构去使用。从此例子可看出，**JSON 是树状结构**

> **JSON的数据类型**

JSON 只包含 6 种数据类型：

- null: 表示为 null
- boolean: 表示为 true 或 false
- number: 不区分整数与浮点数。JavaScript用双精度浮点数 double表示所有数值。
- string: 表示为 "..."，以双引号 " " 括起来的零个或多个 Unicode码位。支持反斜杠开始的转义字符序列。
- array: 表示为 [ ... ]，有序的零个或者多个值
- object: 表示为 { ... }，若干无序的 “键值对” (key-value pairs)，其中键是数值或字符串，以花括号 { 开始，并以 } 结束。

> **补充**

- 1. **JSON 对象**是一个若干无序的 “名称 /值” 键值对的集合：
  - 以 `“{”` 开始，以`“}”` 结束，允许嵌套使用；
  - 每个名称和值成对出现，名称和值之间使用 `“:”` 分隔；
  - 键值对之间用 `“,”` 分隔
  - 在这些字符前后允许存在无意义的空白符；
- 2. **JSON 数组**是一个有序的零个或者多个值的序列表：
  - 以 `“[”` 开始，以 `“]”` 结束，允许嵌套使用；
  - 每个值可以为任意类型，可以是双引号括起来的字符串（string）、数值（number）、true、false、 null、对象（object）或者数组（array）；
  - 元素之间用 “,” 分隔
  - 在这些元素前后允许存在无意义的空白符；


> **实现 JSON 解析的需求**

1. 把 JSON 文本解析为一个链表结构 ~~树状数据结构~~（parse）。
2. 提供接口访问该数据结构（access）。
3. 把数据结构转换成 JSON 文本（stringify）。

![requirement](https://pic2.zhimg.com/80/75eecb0312e129d64dd3b028e1479e3d_1440w.webp)

## 三、JSON数据类型定义与数据结构

### 3.1 #include防范（#include gurad）

C语言中头文件的概念，主要是使用`#include`**引入头文件中的类型声明和函数声明**，但由于头文件也可以`#include`其他头文件，为避免重复声明，因此通常会利用宏加入 `#include` 防范（`include guard`）：

```h
#ifndef cJSON__h
#define cJSON__h
/* ... */

#endif /* cJSON__h */
```

宏的名字必须是唯一的，通常习惯以` _H__` 作为后缀。(cJSON使用`__h`)

由于 cJSON 只有一个头文件，可以简单命名为 cJSON__h。

如果**项目有多个文件或目录结构**，可以用 `项目名称_目录_文件名称_H__` 这种命名方式。

### 3.2 JSON 数据类型定义

除上述**JSON的6种数据类型**，cJSON还定义了另外5中数据类型

**cJSON数据类型定义说明如下：**
- `cJSON_Invalid`（check with `cJSON_IsInvalid`）：表示不包含任何值的无效项。如果将`JSON`设置为全零字节，则为无效数据类型
- `cJSON_False`（check with `cJSON_IsFalse`）: 布尔值`False`,也可以使用`cJSON_IsBool`检查
- `cJSON_True`（check with `cJSON_IsTrue`）: 布尔值`True`,也可以使用`cJSON_IsBool`检查
- `cJSON_NULL` (check with `cJSON_IsNull`): `null`值
- `cJSON_Number` (check with `cJSON_IsNumber`)：该值在 `valuedouble` 和 `valueint `中**存储为双精度值**。如果数字超出整数范围，则 `INT_MAX` 或 `INT_MIN` 存储于 `valueint`。
- `cJSON_String`（check with `cJSON_IsString`）：表示一个字符串值。它以零终止字符串的形式存储在 `valuestring` 中。
- `cJSON_Array`（check with `cJSON_IsArray`）：表示一个数组值，通过链表实现。其中 `child` 指向表示数组中的 `cJSON` 元素。这些元素使用 `next` 和 `prev` 链接在一起，其中第一个元素具有 `prev.next == NULL`，最后一个元素 `next == NULL`。
- `cJSON_Object` (check with `cJSON_IsObject`):表示一个对象值。存储方式与数组相同，唯一的区别是对象中的`key`存储在`string`中
- `cJSON_IsReference`指定`child`指向的`item and/or valuestring`不属于此项，它只是一个引用。所以 `cJSON_Delete` 和其他函数只会释放这个`item`，而不是它的`child/valuestring`。用来**判断当前变量是否为引用**（c语言中符号&）。众所周知，在c语言中，当一个变量以引用的方式作为函数参数传递时，等价于将其地址传递给函数，函数中对该变量操作会直接体现在该变量上，当函数调用结束时，此变量会发生改变。在cJSON中的主要体现在释放内存过程中，因为cJON中以链表来定义JSON，结构体中会用指针来定义一些量，例如字符串，如果是引用就会直接影响到字符串的值。
- `cJSON_StringIsConst`:这意味着`string`指向一个常量字符串(`const string`)。这意味着 `cJSON_Delete` 和其他函数不会尝试释放`string`。

```h
/* cJSON Types: 
   C 语言没有 C++ 的命名空间（namespace）功能，一般会使用项目的简写作为标识符的前缀，如 cJSON_Invalid
*/
#define cJSON_Invalid (0)
#define cJSON_False  (1 << 0)
#define cJSON_True   (1 << 1)
#define cJSON_NULL   (1 << 2)
#define cJSON_Number (1 << 3)
#define cJSON_String (1 << 4)
#define cJSON_Array  (1 << 5)
#define cJSON_Object (1 << 6)
#define cJSON_Raw    (1 << 7) /* raw json */

#define cJSON_IsReference 256
#define cJSON_StringIsConst 512
```

### 3.3 JSON的数据结构

C 语言的结构体是以 `struct X {}` 形式声明的，定义变量时也要写成 `struct X x`;。为方便使用，上面的代码使用了 `typedef`。

从下面的代码可以看出，**cJSON的设计思想是 — 链表**

```h
/* The cJSON structure: */
typedef struct cJSON
{
    /* next/prev allow you to walk array/object chains. Alternatively, use GetArraySize/GetArrayItem/GetObjectItem */
    struct cJSON *next;
    struct cJSON *prev;

    /* An array or object item will have a child pointer pointing to a chain of the items in the array/object. */
    struct cJSON *child;

    /* The type of the item, as above. */
    int type;

    /* The item's string, if type==cJSON_String  and type == cJSON_Raw */
    char *valuestring;
    
    /* writing to valueint is DEPRECATED, use cJSON_SetNumberValue instead */
    int valueint;
    
    /* The item's number, if type==cJSON_Number */
    double valuedouble;

    /* The item's name string, if this item is the child of, or is in the list of subitems of an object. */
    char *string;
} cJSON;
```

> **cJSON数据结构说明**

- `next/prev`：指向下一个/上一个键值对，用于遍历数组，对象链表、
- `child`: 该子指针指向当前数组 /对象中的节点，只有`JSON`的类型为数组(`array`)或对象(`object`)时，里面才会有内容，指向数组的第一个元素，或者对象的第一个键值对
- `type`：用于表示该键值对中值的类型，即[2.2.2节中定义的11种数据类型](#222-json-数据类型定义)
- `valuestring`,`valueint`,`valuedouble`：保存当前`JSON`值(value)的地址,根据`type`的不同使用不同的存储类型；如果是`JSON Object`类型，它的键(key)地址存储在`string`中。其他时候`string`为空
- **注意：**`type=cJSON_False`时，它就是一个`bool`型的`false`结构体中其他成员都为`0，`没有前驱也没有后继，更不会有`child`。当`type= cJSON_Number`时，这个`JSON`表示的就是一个数。

> **cJSON_Hooks**

向cJSON提供`malloc`和`free`函数

cJSON库在使用的过程中，会涉及到分配内存和释放内存，在默认情况下，他调用的是C语言标准库中的malloc函数和free函数，下面是cJSON库的代码：

```c
/* Reset hooks */
  global_hooks.allocate = malloc;
  global_hooks.deallocate = free;
  global_hooks.reallocate = realloc;
```

```h
typedef struct cJSON_Hooks
{
    /* malloc/free are CDECL on Windows regardless of the default calling convention of the compiler, so ensure the hooks allow passing those functions directly. */
    void *(CJSON_CDECL *malloc_fn)(size_t sz);
    void (CJSON_CDECL *free_fn)(void *ptr);
} cJSON_Hooks;

/* Supply malloc, realloc and free functions to cJSON */
CJSON_PUBLIC(void) cJSON_InitHooks(cJSON_Hooks* hooks);
```

在嵌入式开发中，往往我们所在的**开发平台有自己的内存管理函数**。如果我们需要cJSON调用自己平台的内存管理函数，就要用到`cJSON_Hooks`与`cJSON_InitHooks`函数。

## 四、创建cJSON数据

对于每种`type`，都有一个与之对应的`cJSON_Create...`方法用于创建该类型的节点，所有方法都会创建一个`cJSON struct`结构体，可以使用`cJSON_Delete`释放它

注意：

- 不能使用`cJSON_Delete`释放`array`或`object`当中的元素，当`arra`y或者`object`被释放时，其中的元素也会自动释放
- 可以使用`cJSON_SetValueString`改变`cJSON_String`节点的`valuestring`值，而不需要手动释放之前的`valuestring`

### 4.1 基本数据类型(appropriate type)

| 类型  | 创建方法  | 说明  |
| ---  | ---  | ---  |
| null  | `cJSON_CreateNull`  |   |
| boolean  | `cJSON_CreateTrue/cJSON_CreateFalse/cJSON_CreateBool`  |   |
| number  | `cJSON_CreateNumber`  | 将同时设置`valuedouble`和`valueint`，如果数字的值超过整形范围，则`valueint`将被设为`INT_MAX`或`INT_MIN`  |
| string  | `cJSON_CreateString/cJSON_CreateStringReference`  | `cJSON_CreateString`会拷贝字符串，而`cJSON_CreateStringReference`直接指向设置的字符串  |


```c
/* These calls create a cJSON item of the appropriate type. */
CJSON_PUBLIC(cJSON *) cJSON_CreateNull(void);
CJSON_PUBLIC(cJSON *) cJSON_CreateTrue(void);
CJSON_PUBLIC(cJSON *) cJSON_CreateFalse(void);
CJSON_PUBLIC(cJSON *) cJSON_CreateBool(cJSON_bool boolean);
CJSON_PUBLIC(cJSON *) cJSON_CreateNumber(double num);
CJSON_PUBLIC(cJSON *) cJSON_CreateString(const char *string);
```

### 4.2 数组

### 4.3 对象


## 五、cJSON解析与输出JSON

