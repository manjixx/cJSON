# cJSON 学习笔记

[项目源码](https://github.com/DaveGamble/cJSON#**example**)
[从零开始的 JSON 库教程](https://zhuanlan.zhihu.com/json-tutorial)
[cJSON库 API解析](https://blog.csdn.net/qq_42992084/article/details/113445340)
[博客园 cJSON教程](https://www.cnblogs.com/qinjinyu/p/14086938.html)

## 一、 环境配置

```sh
git clone git@github.com:DaveGamble/cJSON.git
mkdir bulid
cd build
cmake ..
```

详细内容请参见[项目源码](https://github.com/DaveGamble/cJSON#**example**)内`README`。

## 二、JSON

> **JSON是什么**

JSON（JavaScript Object Notation）是一个用于数据交换的文本格式，现时的标准为[ECMA-404](https://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf)。

虽然 JSON 源至于 JavaScript 语言，但它只是一种数据格式，可用于任何编程语言。现时具类似功能的格式有 XML、YAML，当中以 JSON 的语法最为简单。

例如，一个动态网页想从服务器获得数据时，服务器从数据库查找数据，然后把数据转换成 JSON 文本格式：

```js
{
    "title": "Design Patterns",
    "subtitle": "Elements of Reusable Object-Oriented Software",
    "author": [
        "Erich Gamma",
        "Richard Helm",
        "Ralph Johnson",
        "John Vlissides"
    ],
    "year": 2009,
    "weight": 1.8,
    "hardcover": true,
    "publisher": {
        "Company": "Pearson Education",
        "Country": "India"
    },
    "website": null
}
```

网页的脚本代码就可以把此 JSON 文本解析为内部的数据结构去使用。从此例子可看出，**JSON 是树状结构**

> **JSON的数据类型**

JSON 只包含 6 种数据类型：

- `null`: 表示为 null
- `boolean`: 表示为 true 或 false
- `number`: 不区分整数与浮点数。JavaScript用双精度浮点数 `double`表示所有数值。
- `string`: 表示为 "..."，以双引号 " " 括起来的零个或多个 Unicode码位。支持反斜杠开始的转义字符序列。
- `array`: 表示为 [ ... ]，有序的零个或者多个值
- `object`: 表示为 { ... }，若干无序的 “键值对” (key-value pairs)，其中键是数值或字符串，以花括号 { 开始，并以 } 结束。

> **补充**

- 1. **JSON 对象**是一个若干无序的 “名称 /值” 键值对的集合：
  - 以 `“{”` 开始，以`“}”` 结束，允许嵌套使用；
  - 每个名称和值成对出现，名称和值之间使用 `“:”` 分隔；
  - 键值对之间用 `“,”` 分隔
  - 在这些字符前后允许存在无意义的空白符；
- 2. **JSON 数组**是一个有序的零个或者多个值的序列表：
  - 以 `“[”` 开始，以 `“]”` 结束，允许嵌套使用；
  - 每个值可以为任意类型，可以是双引号括起来的字符串（string）、数值（number）、true、false、 null、对象（object）或者数组（array）；
  - 元素之间用 “,” 分隔
  - 在这些元素前后允许存在无意义的空白符；


> **实现 JSON 解析的需求**

1. 把 JSON 文本解析为一个链表结构 树状数据结构（parse）。
2. 提供接口访问该数据结构（access）。
3. 把数据结构转换成 JSON 文本（stringify）。

![requirement](https://pic2.zhimg.com/80/75eecb0312e129d64dd3b028e1479e3d_1440w.webp)

## 三、JSON数据类型定义与数据结构

### 3.1 #include防范（#include gurad）

C语言中头文件的概念，主要是使用`#include`**引入头文件中的类型声明和函数声明**，但由于头文件也可以`#include`其他头文件，为避免重复声明，因此通常会利用宏加入 `#include` 防范（`include guard`）：

```h
#ifndef cJSON__h
#define cJSON__h
/* ... */

#endif /* cJSON__h */
```

宏的名字必须是唯一的，通常习惯以` _H__` 作为后缀。(cJSON使用`__h`)

由于 cJSON 只有一个头文件，可以简单命名为 cJSON__h。

如果**项目有多个文件或目录结构**，可以用 `项目名称_目录_文件名称_H__` 这种命名方式。

### 3.2 JSON 数据类型定义

除上述**JSON的6种数据类型**，cJSON还定义了另外5中数据类型

**cJSON数据类型定义说明如下：**
- `cJSON_Invalid`（check with `cJSON_IsInvalid`）：表示不包含任何值的无效项。如果将`JSON`设置为全零字节，则为无效数据类型
- `cJSON_False`（check with `cJSON_IsFalse`）: 布尔值`False`,也可以使用`cJSON_IsBool`检查
- `cJSON_True`（check with `cJSON_IsTrue`）: 布尔值`True`,也可以使用`cJSON_IsBool`检查
- `cJSON_NULL` (check with `cJSON_IsNull`): `null`值
- `cJSON_Number` (check with `cJSON_IsNumber`)：该值在 `valuedouble` 和 `valueint `中**存储为双精度值**。如果数字超出整数范围，则 `INT_MAX` 或 `INT_MIN` 存储于 `valueint`。
- `cJSON_String`（check with `cJSON_IsString`）：表示一个字符串值。它以零终止字符串的形式存储在 `valuestring` 中。
- `cJSON_Array`（check with `cJSON_IsArray`）：表示一个数组值，通过链表实现。其中 `child` 指向表示数组中的 `cJSON` 元素。这些元素使用 `next` 和 `prev` 链接在一起，其中第一个元素具有 `prev.next == NULL`，最后一个元素 `next == NULL`。
- `cJSON_Object` (check with `cJSON_IsObject`):表示一个对象值。存储方式与数组相同，唯一的区别是对象中的`key`存储在`string`中
- `cJSON_IsReference`指定`child`指向的`item and/or valuestring`不属于此项，它只是一个引用。所以 `cJSON_Delete` 和其他函数只会释放这个`item`，而不是它的`child/valuestring`。用来**判断当前变量是否为引用**（c语言中符号&）。众所周知，在c语言中，当一个变量以引用的方式作为函数参数传递时，等价于将其地址传递给函数，函数中对该变量操作会直接体现在该变量上，当函数调用结束时，此变量会发生改变。在cJSON中的主要体现在释放内存过程中，因为cJON中以链表来定义JSON，结构体中会用指针来定义一些量，例如字符串，如果是引用就会直接影响到字符串的值。
- `cJSON_StringIsConst`:这意味着`string`指向一个常量字符串(`const string`)。这意味着 `cJSON_Delete` 和其他函数不会尝试释放`string`。

```h
/* cJSON Types: 
   C 语言没有 C++ 的命名空间（namespace）功能，一般会使用项目的简写作为标识符的前缀，如 cJSON_Invalid
*/
#define cJSON_Invalid (0)
#define cJSON_False  (1 << 0)
#define cJSON_True   (1 << 1)
#define cJSON_NULL   (1 << 2)
#define cJSON_Number (1 << 3)
#define cJSON_String (1 << 4)
#define cJSON_Array  (1 << 5)
#define cJSON_Object (1 << 6)
#define cJSON_Raw    (1 << 7) /* raw json */

#define cJSON_IsReference 256
#define cJSON_StringIsConst 512
```

### 3.3 JSON的数据结构

C 语言的结构体是以 `struct X {}` 形式声明的，定义变量时也要写成 `struct X x`;。为方便使用，上面的代码使用了 `typedef`。

从下面的代码可以看出，**cJSON的设计思想是 — 链表**

```h
/* The cJSON structure: */
typedef struct cJSON
{
    /* next/prev allow you to walk array/object chains. Alternatively, use GetArraySize/GetArrayItem/GetObjectItem */
    struct cJSON *next;
    struct cJSON *prev;

    /* An array or object item will have a child pointer pointing to a chain of the items in the array/object. */
    struct cJSON *child;

    /* The type of the item, as above. */
    int type;

    /* The item's string, if type==cJSON_String  and type == cJSON_Raw */
    char *valuestring;
    
    /* writing to valueint is DEPRECATED, use cJSON_SetNumberValue instead */
    int valueint;
    
    /* The item's number, if type==cJSON_Number */
    double valuedouble;

    /* The item's name string, if this item is the child of, or is in the list of subitems of an object. */
    char *string;
} cJSON;
```

> **cJSON数据结构说明**

- `next/prev`：指向下一个/上一个键值对，用于遍历数组，对象链表、
- `child`: 该子指针指向当前数组 /对象中的节点，只有`JSON`的类型为数组(`array`)或对象(`object`)时，里面才会有内容，指向数组的第一个元素，或者对象的第一个键值对
- `type`：用于表示该键值对中值的类型，即[2.2.2节中定义的11种数据类型](#222-json-数据类型定义)
- `valuestring`,`valueint`,`valuedouble`：保存当前`JSON`值(value)的地址,根据`type`的不同使用不同的存储类型；如果是`JSON Object`类型，它的键(key)地址存储在`string`中。其他时候`string`为空
- **注意：**`type=cJSON_False`时，它就是一个`bool`型的`false`结构体中其他成员都为`0，`没有前驱也没有后继，更不会有`child`。当`type= cJSON_Number`时，这个`JSON`表示的就是一个数。

> **cJSON_Hooks**

向cJSON提供`malloc`和`free`函数

cJSON库在使用的过程中，会涉及到分配内存和释放内存，在默认情况下，他调用的是C语言标准库中的`malloc`函数和`free`函数，下面是`cJSON`库的代码：

```c
/* Reset hooks */
  global_hooks.allocate = malloc;
  global_hooks.deallocate = free;
  global_hooks.reallocate = realloc;
```

```h
typedef struct cJSON_Hooks
{
    /* malloc/free are CDECL on Windows regardless of the default calling convention of the compiler, so ensure the hooks allow passing those functions directly. */
    void *(CJSON_CDECL *malloc_fn)(size_t sz);
    void (CJSON_CDECL *free_fn)(void *ptr);
} cJSON_Hooks;

/* Supply malloc, realloc and free functions to cJSON */
CJSON_PUBLIC(void) cJSON_InitHooks(cJSON_Hooks* hooks);
```

在嵌入式开发中，往往我们所在的**开发平台有自己的内存管理函数**。如果我们需要cJSON调用自己平台的内存管理函数，就要用到`cJSON_Hooks`与`cJSON_InitHooks`函数。

## 四、创建cJSON数据

对于每种`type`，都有一个与之对应的`cJSON_Create...`方法用于创建该类型的节点，所有方法都会创建一个`cJSON struct`结构体，可以使用`cJSON_Delete`释放它

注意：

- 不能使用`cJSON_Delete`释放`array`或`object`当中的元素，当`arra`y或者`object`被释放时，其中的元素也会自动释放
- 可以使用`cJSON_SetValueString`改变`cJSON_String`节点的`valuestring`值，而不需要手动释放之前的`valuestring`

### 4.1 基本数据类型(appropriate type)

> **创建基本数据类型**

| 类型  | 创建方法  | 说明  |
| ---  | ---  | ---  |
| null  | `cJSON_CreateNull`  |   |
| boolean  | `cJSON_CreateTrue/cJSON_CreateFalse/cJSON_CreateBool`  |   |
| number  | `cJSON_CreateNumber`  | 将同时设置`valuedouble`和`valueint`，如果数字的值超过整形范围，则`valueint`将被设为`INT_MAX`或`INT_MIN`  |
| string  | `cJSON_CreateString/cJSON_CreateStringReference`  | `cJSON_CreateString`会拷贝字符串，而`cJSON_CreateStringReference`直接指向设置的字符串  |


```c
/* These calls create a cJSON item of the appropriate type. */
CJSON_PUBLIC(cJSON *) cJSON_CreateNull(void);
CJSON_PUBLIC(cJSON *) cJSON_CreateTrue(void);
CJSON_PUBLIC(cJSON *) cJSON_CreateFalse(void);
CJSON_PUBLIC(cJSON *) cJSON_CreateBool(cJSON_bool boolean);
CJSON_PUBLIC(cJSON *) cJSON_CreateNumber(double num);
CJSON_PUBLIC(cJSON *) cJSON_CreateString(const char *string);
// 创建字符串类引用，无法被 cJSON_Delete 释放
CJSON_PUBLIC(cJSON *) cJSON_CreateStringReference(const char *string);
```

> **检查数据类型**

```h
CJSON_PUBLIC(cJSON_bool) cJSON_IsInvalid(const cJSON * const item);
CJSON_PUBLIC(cJSON_bool) cJSON_IsFalse(const cJSON * const item);
CJSON_PUBLIC(cJSON_bool) cJSON_IsTrue(const cJSON * const item);
CJSON_PUBLIC(cJSON_bool) cJSON_IsBool(const cJSON * const item);
CJSON_PUBLIC(cJSON_bool) cJSON_IsNull(const cJSON * const item);
CJSON_PUBLIC(cJSON_bool) cJSON_IsNumber(const cJSON * const item);
CJSON_PUBLIC(cJSON_bool) cJSON_IsString(const cJSON * const item);
CJSON_PUBLIC(cJSON_bool) cJSON_IsArray(const cJSON * const item);
CJSON_PUBLIC(cJSON_bool) cJSON_IsObject(const cJSON * const item);
CJSON_PUBLIC(cJSON_bool) cJSON_IsRaw(const cJSON * const item);
```

> **其他**

```h
/* When assigning an integer value, it needs to be propagated to valuedouble too. */
#define cJSON_SetIntValue(object, number) ((object) ? (object)->valueint = (object)->valuedouble = (number) : (number))
/* helper for the cJSON_SetNumberValue macro */
CJSON_PUBLIC(double) cJSON_SetNumberHelper(cJSON *object, double number);
#define cJSON_SetNumberValue(object, number) ((object != NULL) ? cJSON_SetNumberHelper(object, (double)number) : (number))
/* Change the valuestring of a cJSON_String object, only takes effect when type of object is cJSON_String */
CJSON_PUBLIC(char*) cJSON_SetValuestring(cJSON *object, const char *valuestring);

/* If the object is not a boolean type this does nothing and returns cJSON_Invalid else it returns the new type*/
#define cJSON_SetBoolValue(object, boolValue) ( \
    (object != NULL && ((object)->type & (cJSON_False|cJSON_True))) ? \
    (object)->type=((object)->type &(~(cJSON_False|cJSON_True)))|((boolValue)?cJSON_True:cJSON_False) : \
    cJSON_Invalid\
)
```

### 4.2 数组

> **1. 创建数组**

```h
/*创建一个空数组*/
CJSON_PUBLIC(CJSON *) cJSON_CreateArray(void);
/*创建一个数组，但是它里面的所有元素都不属于它自己，所以不能使用cJSON_Delete删除它里面的内容*/
CJSON_PUBLIC(CJSON *) cJSON_CreateArrayReference(const cJSON* child);

/*以下函数创造具体长度的数组
  注：实际数组长度不能大于指定长度的数组，否则数组长度会out of bounds
*/
CJSON_PUBLIC(cJSON *) cJSON_CreateIntArray(const int *numbers, int count);
CJSON_PUBLIC(cJSON *) cJSON_CreateFloatArray(const float *numbers, int count);
CJSON_PUBLIC(cJSON *) cJSON_CreateDoubleArray(const double *numbers, int count);
CJSON_PUBLIC(cJSON *) cJSON_CreateStringArray(const char *const *strings, int count);
```

> **2. 向数组中添加/更新元素**

```h
/*数组尾端添加元素*/
cJSON_PUBLIC(cJSON_bool) cJSON_AddIteamToArray(cJSON *array, cJSON *item);
/*将另一个元素的引用添加进数组*/
CJSON_PUBLIC(cJSON_bool) cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item);
/*在指定索引处插入元素*/
CJSON_PUBLIC(cJSON_bool) cJSON_InsertItemInArray(cJSON *array, int which, cJSON *newItem);
/*替换数组中指定位置元素*/
CJSON_PUBLIC(cJSON_bool) cJSON_ReplaceItemInArray(cJSON *array, int which, cJSON *newItem);
// 根据指针替换元素，失败返回0
CJSON_PUBLIC(cJSON_bool) cJSON_ReplaceItemViaPointer(cJSON * const parent, cJSON * const item, cJSON * replacement);
```

> **3. 获取数组元素**

```h
// 根据索引获取元素，失败返回 NULL
CJSON_PUBLIC(cJSON *) cJSON_GetArrayItem(const cJSON *array, int index);
// 根据索引获取数组中的元素，并将其从数组中分离，以便后续能够继续使用
CJSON_PUBLIC(cJSON *) cJSON_DetachItemViaPointer(cJSON *parent, cJSON * const item);
```

> **4. 删除数组中的元素**

```h
// 根据索引删除数组中的元素
CJSON_PUBLIC(void) cJSON_DeleteItemFromArray(cJSON *array, int which);
```

> **5. 获取数组的大小**

```h
CJSON_PUBLIC(int) cJSON_GetArraySize(const cJSON *array);
```

> **6. 迭代数组中元素**

```h
// 在O(n)的时间内迭代数组中的元素
#define cJSON_ArrayForEach(element, array) for(element = (array != NULL) ? (array)->child : NULL; element != NULL; element = element->next)
```

### 4.3 对象

> **1. 创建对象**

```h
// 创建一个空对象
CJSON_PUBLIC(cJSON *) cJSON_CreateObject(void);
// 创建一个对象，但是它里面的所有元素都不属于它自己，所以不能使用cJSON_Delete删除它里面的内容
CJSON_PUBLIC(cJSON *) cJSON_CreateObjectReference(const cJSON *child);
```

> **2. 向对象中添加元素**

```h
// 向对象中添加一个元素
CJSON_PUBLIC(cJSON_bool) cJSON_AddItemToObject(cJSON *object, const char *string, cJSON *item);
// 向对象中添加一个名称（对象的key，即cJSON结构体中的string）为常量或者引用的元素
CJSON_PUBLIC(cJSON_bool) cJSON_AddItemToObjectCS(cJSON *object, const char *string, cJSON *item);
// 将另一个元素的引用添加进对象
CJSON_PUBLIC(cJSON_bool) cJSON_AddItemReferenceToObject(cJSON *object, const char *string, cJSON *item);
```

> **3. 替换对象中的元素**

```h
// 根据key替换对象中的元素
CJSON_PUBLIC(cJSON_bool) cJSON_ReplaceItemInObject(cJSON *object,const char *string,cJSON *newitem);
// 根据key替换对象中的元素,大小写敏感
CJSON_PUBLIC(cJSON_bool) cJSON_ReplaceItemInObjectCaseSensitive(cJSON *object,const char *string,cJSON *newitem);
// 根据指针替换对象中的元素，失败返回0
CJSON_PUBLIC(cJSON_bool) cJSON_ReplaceItemViaPointer(cJSON * const parent, cJSON * const item, cJSON * replacement);
```

> **4. 获取对象中的元素**

```h
// 判断对象中是否有元素
CJSON_PUBLIC(cJSON_bool) cJSON_HasObjectItem(const cJSON *object, const char *string);
// 获取对象中的元素 Case insensitive
CJSON_PUBLIC(cJSON *) cJSON_GetObjectItem(const cJSON * const object, const char * const string);
// 获取对象中的元素 Case sensitive
CJSON_PUBLIC(cJSON *) cJSON_GetObjectItemCaseSensitive(const cJSON * const object, const char * const string);
// 分离并获取对象中的元素
CJSON_PUBLIC(cJSON *) cJSON_DetachItemFromObjectCaseSensitive(cJSON *object, const char *string);
```

> **5. 删除对象中的元素**

```h
// 删除对象中的元素 Case insensitive
CJSON_PUBLIC(void) cJSON_DeleteItemFromObject(cJSON *object, const char *string);
// 删除对象中的元素 Case Sensitive
CJSON_PUBLIC(void) cJSON_DeleteItemFromObjectCaseSensitive(cJSON *object, const char *string);
```

> **6. 获取对象大小**

```h
CJSON_PUBLIC(int) cJSON_GetArraySize(const cJSON *array);
```

> **7. 迭代对象中的元素**

```h
#define cJSON_ArrayForEach(element, array) for(element = (array != NULL) ? (array)->child : NULL; element != NULL; element = element->next)
```

> **8. 快速创建对象并添加元素到对象** 

cJSON提供了快速创建并添加到对象的方法，这些方法返回指向新创建元素的指针，**如果失败，则返回NULL**

```h
CJSON_PUBLIC(cJSON*) cJSON_AddNullToObject(cJSON * const object, const char * const name);
CJSON_PUBLIC(cJSON*) cJSON_AddTrueToObject(cJSON * const object, const char * const name);
CJSON_PUBLIC(cJSON*) cJSON_AddFalseToObject(cJSON * const object, const char * const name);
CJSON_PUBLIC(cJSON*) cJSON_AddBoolToObject(cJSON * const object, const char * const name, const cJSON_bool boolean);
CJSON_PUBLIC(cJSON*) cJSON_AddNumberToObject(cJSON * const object, const char * const name, const double number);
CJSON_PUBLIC(cJSON*) cJSON_AddStringToObject(cJSON * const object, const char * const name, const char * const string);
CJSON_PUBLIC(cJSON*) cJSON_AddRawToObject(cJSON * const object, const char * const name, const char * const raw);
CJSON_PUBLIC(cJSON*) cJSON_AddObjectToObject(cJSON * const object, const char * const name);
CJSON_PUBLIC(cJSON*) cJSON_AddArrayToObject(cJSON * const object, const char * const name);
```


## 五、其他

```h
/* returns the version of cJSON as a string */
CJSON_PUBLIC(const char*) cJSON_Version(void);

/* Duplicate a cJSON item */
/* Duplicate will create a new, identical cJSON item to the one you pass, in new memory that will
 * need to be released. With recurse!=0, it will duplicate any children connected to the item.
 * The item->next and ->prev pointers are always zero on return from Duplicate. */
CJSON_PUBLIC(cJSON *) cJSON_Duplicate(const cJSON *item, cJSON_bool recurse);

/* Recursively compare two cJSON items for equality. If either a or b is NULL or invalid, they will be considered unequal.
 * case_sensitive determines if object keys are treated case sensitive (1) or case insensitive (0) */
CJSON_PUBLIC(cJSON_bool) cJSON_Compare(const cJSON * const a, const cJSON * const b, const cJSON_bool case_sensitive);

/* Minify a strings, remove blank characters(such as ' ', '\t', '\r', '\n') from strings.
 * The input pointer json cannot point to a read-only address area, such as a string constant, 
 * but should point to a readable and writable address area. */
CJSON_PUBLIC(void) cJSON_Minify(char *json);

/* Delete a cJSON entity and all subentities. */
CJSON_PUBLIC(void) cJSON_Delete(cJSON *item);

```

## 六、cJSON解析与输出JSON

### 6.1 解析JSON

cJSON提供的解析函数的返回值需要调用方手动调用 cJSON—Delete 释放

```h
/* Memory Management: the caller is always responsible to free the results from all variants of cJSON_Parse (with cJSON_Delete) and cJSON_Print (with stdlib free, cJSON_Hooks.free_fn, or cJSON_free as appropriate). The exception is cJSON_PrintPreallocated, where the caller has full responsibility of the buffer. */

/*
  解析以'\0'结尾的JSON字符串
  Supply a block of JSON, and this returns a cJSON object you can interrogate.
 */
CJSON_PUBLIC(cJSON *) cJSON_Parse(const char *value);

/* 
  解析指定长度的JSON字符串（可以不以'\0'结尾）
*/
CJSON_PUBLIC(cJSON *) cJSON_ParseWithLength(const char *value, size_t buffer_length);

/* ParseWithOpts allows you to require (and check) that the JSON is null terminated, and to retrieve the pointer to the final byte parsed. */
/* If you supply a ptr in return_parse_end and parsing fails, then return_parse_end will contain a pointer to the error so will match cJSON_GetErrorPtr(). */
/*
  - return_parse_end: 返回指向输入字符串中JSON的结束位置
  - require_null_terminated: 是否禁止 输入字符串中的JSON 后面还包含有数据
*/
CJSON_PUBLIC(cJSON *) cJSON_ParseWithOpts(const char *value, const char **return_parse_end, cJSON_bool require_null_terminated);

/*解析指定长度字符串以及带操作的解析*/
CJSON_PUBLIC(cJSON *) cJSON_ParseWithLengthOpts(const char *value, size_t buffer_length, const char **return_parse_end, cJSON_bool require_null_terminated);
```

### 6.2 输出JSON

cJSON提供的输出函数的返回值需要手动调用free释放

```h
/*
  输出经过空白字符格式化后的JSON
  Render a cJSON entity to text for transfer/storage. 
*/
CJSON_PUBLIC(char *) cJSON_Print(const cJSON *item);

/* 
  输出没有经过空白字符格式化后的JSON
  Render a cJSON entity to text for transfer/storage without any formatting. 
*/
CJSON_PUBLIC(char *) cJSON_PrintUnformatted(const cJSON *item);

/* 
  输出JSON到指定大小的buffer
  - prebuffer：指定输出buffer的初始大小
  - fmt：是否使用空白字符进行格式化
  Render a cJSON entity to text using a buffered strategy. prebuffer is a guess at the final size. guessing well reduces reallocation. fmt=0 gives unformatted, =1 gives formatted 
*/
CJSON_PUBLIC(char *) cJSON_PrintBuffered(const cJSON *item, int prebuffer, cJSON_bool fmt);
/* Render a cJSON entity to text using a buffer already allocated in memory with given length. Returns 1 on success and 0 on failure. */
/* NOTE: cJSON is not always 100% accurate in estimating how much memory it will use, so to be safe allocate 5 bytes more than you actually need */
/*
  输出JSON到静态buffer，从而避免动态分配内存，当buffer大小不够时，调用失败，返回0，成功时返回1
*/
CJSON_PUBLIC(cJSON_bool) cJSON_PrintPreallocated(cJSON *item, char *buffer, const int length, const cJSON_bool format);
```